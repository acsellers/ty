Stubbed Functions
ParEach(f, xs) Call f on each element of xs in parallel

Missing Functions
CycleEach(f, xs, int) Call f on xs int times in succession
CycleMap(f, xs, int) Call f on xs int times in succession and return the results
CycleFor(f, xs) Class f on xs forever
EachSlice(f, xs, n) Call f with n elements of xs
ParEachSlice(f, xs, n) Call f on each element of xs with n parallel goroutines
FindIndex(f, xs) Return the first index where f returns true, otherwise nil
Grep(xs, regex) Returns the strings for which regex matches
GroupBy(f, xs) Returns a mapping from return value of f to array of elements that were put in
Include(x, xs) Returns whether x is in xs
Combination(xs, n) Returns all unique combinations of elements of xs with n elements
Permutations(xs, n) Returns all unique ordering of combinations of elements of xs with n elements
Compact(xs) Returns all elemenets of xs that aren't nil
Delete(xs, x) Returns xs missing the nil instances of x
Replace(xs, ys) Replaces elements in xs with elements from ys until ys is empty or xs has been fully replaced
Join(xs, s) Joins elements of xs by calling either calling String() or joining strings or calling fmt.Sprint

Intentionally Missing Functions
Drop(f, int) Drop first int elements from f - use slicing
EachWithIndex(f, xs) Call each f with the element and index - use range function
ToA(xs) Return a slice of xs, we don't have sparse ranges
FindAll(f, xs) Use Filter - no synonyms
First(xs) Returns the first element - use xs[0]
Inject(f, xs) Use Reduce - no synonyms
Collect(f, xs) Use Map - no synonyms
SortBy(f, xs) Use Sort - go doesn't have a generic sort
Take(xs, n) Get first n elements from xs - use slicing
TakeWhile(f, xs) Renamed to Take, since we weren't using it
ToSet(xs) Use Set - no synonyms
Exclude(x, xs) Use !Include - too similar
Many(xs) Use len(xs) > 1
DeleteIf(xs, f) Use Filter - not touching your slices
DeleteAt(xs, n) Use del(xs, n)
NItems(xs) Returns non-nil length of xs - maybe later
Flatten(xxs) Concats each array in xxs into a single array - Concat does this

More Intentionally Missing Functions that would best belong in a more specific library
Abbrev(xs) Returns all shortening of elements of xs for which another element could not be similarly shortened
Assoc(xs, x) Returns the array contained in xs that starts with x
RAssoc(xs, x) Returns the array contained in xs that ends with x

Unsure Missing Functions
Choice(xs, r) Returns a random element of xs according to rand
